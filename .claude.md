# Trove Project Context

## Project Overview

Trove is a unified social media archive system that automatically downloads and stores content from multiple platforms (Bluesky, Strava, Instagram), providing a secure API for displaying archived content on personal websites.

**Current Status**: Planning & Architecture Phase ✅

## Tech Stack

- **Backend**: Supabase (PostgreSQL + Edge Functions/Deno + Storage)
- **Database**: PostgreSQL with Row Level Security (RLS)
- **Storage**: Supabase Storage (S3-compatible)
- **Platforms**: Bluesky (AT Protocol), Strava API v3, Instagram Graph API
- **Sync Strategy**: Hybrid (webhooks + scheduled polling)
- **Language**: TypeScript (Edge Functions), SQL (migrations)

## Project Structure

```
trove/
├── README.md                    # Project overview
├── PLAN.md                      # High-level implementation plan
├── docs/                        # Comprehensive documentation
│   ├── DATABASE_SCHEMA.md       # Complete DB schema, RLS, indexes
│   ├── DATA_FLOWS.md            # System flows (OAuth, sync, webhooks)
│   ├── API_SPECIFICATION.md     # Public API documentation
│   ├── SECURITY_PRIVACY.md      # Security architecture & compliance
│   ├── PLATFORM_BLUESKY.md      # Bluesky integration details
│   ├── PLATFORM_STRAVA.md       # Strava integration details
│   └── PLATFORM_INSTAGRAM.md    # Instagram integration details
├── supabase/                    # (to be created)
│   ├── migrations/              # Database migrations
│   ├── functions/               # Edge Functions
│   └── config.toml              # Supabase configuration
└── .claude/                     # Claude Code settings
    └── settings.local.json
```

## Key Architecture Decisions

1. **Multi-Tenant via RLS**: User data isolated at database level using Supabase RLS
2. **Hybrid Sync**: Real-time webhooks where available + polling fallback
3. **Token Encryption**: OAuth tokens encrypted (AES-256-GCM) before storage
4. **Media Storage**: User-isolated folder structure in Supabase Storage
5. **Idempotent Syncs**: UPSERT pattern ensures safe retries
6. **Denormalized user_id**: Performance optimization for queries

## Database Schema Overview

**Core Tables**:
- `users` - Trove user accounts (maps to Supabase Auth)
- `connected_accounts` - OAuth connections to platforms
- `posts` - Archived posts/activities from all platforms
- `media_assets` - Downloaded media files (images, videos, etc.)
- `sync_logs` - Synchronization history for debugging

**Key Features**:
- All tables use RLS for multi-tenant isolation
- Unique constraints prevent duplicate platform posts
- JSONB fields for platform-specific metadata
- Full-text search on posts via tsvector
- Cascade deletes for data cleanup

See `docs/DATABASE_SCHEMA.md` for complete schema.

## Platform Integration Notes

### Bluesky (AT Protocol)
- OAuth 2.0 with granular scopes (2025 updates)
- Firehose for real-time (advanced) or polling via `getAuthorFeed` (simpler)
- DIDs (Decentralized IDs) as permanent identifiers
- Start here - simplest OAuth implementation

### Strava
- OAuth 2.0, tokens expire every 6 hours (refresh required!)
- ONE webhook subscription per app covers all users
- Webhook payload is minimal - must fetch full activity data via API
- Rate limits: 100 req/15min, 1000 req/day

### Instagram
- OAuth via Facebook Login (requires Business/Creator account)
- NO real-time webhooks for media - polling required
- Carousel posts need special handling (fetch children)
- Stories only available for 24 hours

## API Design

**Public Endpoints** (see `docs/API_SPECIFICATION.md`):
- `GET /api/posts` - List posts with filtering
- `GET /api/posts/:id` - Single post details
- `GET /api/timeline` - Unified chronological feed
- `GET /api/search` - Full-text search
- `GET /api/media/:id` - Media proxy
- `GET /api/stats` - Aggregated statistics

**Authentication**: JWT (Supabase Auth) or API Keys
**Rate Limiting**: 100-500 req/min depending on tier
**Caching**: 5min for lists, 1yr for media

## Security Requirements

- ✅ All API endpoints require authentication
- ✅ RLS policies enforce user data isolation
- ✅ OAuth tokens encrypted before database storage
- ✅ HTTPS-only (TLS 1.2+)
- ✅ Input validation using Zod schemas
- ✅ Webhook signature verification
- ✅ GDPR/CCPA compliant (right to export, delete)
- ✅ Audit logging for security events

See `docs/SECURITY_PRIVACY.md` for complete details.

## Development Workflow

### Current Phase: Planning ✅
All architecture and documentation complete. Ready for implementation.

### Next Phase: Foundation
1. Create Supabase project
2. Write database migrations from `docs/DATABASE_SCHEMA.md`
3. Set up RLS policies
4. Configure Storage buckets
5. Set up environment variables

### Coding Standards

#### JavaScript/TypeScript Style
- **No semicolons** when possible (ASI-safe code)
- **2 space indents** (not tabs)
- **Trailing dot** for multi-line chaining (not leading dot)
- **TypeScript**: Strict mode enabled, use Zod for validation
- **Naming**: camelCase for variables/functions, PascalCase for types/classes

#### Code Quality
- **SQL**: Use parameterized queries (Supabase client handles this)
- **Error Handling**: Always handle errors, log appropriately
- **Security**: Never log tokens/secrets, validate all inputs
- **Testing**: Write tests for auth, RLS, and sync logic

#### Style Examples
```typescript
// ✅ GOOD: No semicolons, trailing dots, 2 spaces
const posts = await supabase.
  from('posts').
  select('*').
  eq('platform', 'bluesky').
  order('created_at_platform', { ascending: false }).
  limit(20)

// ❌ BAD: Semicolons, leading dots
const posts = await supabase
  .from('posts')
  .select('*');
```

## Important Context for AI Assistants

### When Writing Code

1. **Always use RLS-aware queries**:
   ```typescript
   // GOOD: RLS automatically filters by user
   const { data } = await supabase.
     from('posts').
     select('*').
     eq('platform', 'bluesky')

   // Service role bypasses RLS - use carefully!
   const { data } = await supabaseAdmin.
     from('posts').
     insert({ /* data */ })
   ```

2. **Encrypt tokens before storage**:
   ```typescript
   // Always encrypt OAuth tokens
   const encrypted = encryptToken(accessToken, ENCRYPTION_KEY)
   await supabase.
     from('connected_accounts').
     update({ access_token: encrypted })
   ```

3. **Use UPSERT for idempotency**:
   ```typescript
   // Safe to retry - won't create duplicates
   await supabase.
     from('posts').
     upsert({
       platform: 'bluesky',
       platform_post_id: 'unique-id',
       /* other fields */
     }, {
       onConflict: 'platform,platform_post_id'
     })
   ```

4. **Handle token refresh**:
   ```typescript
   // Check expiration before API calls
   if (tokenExpiresAt < Date.now() + 5 * 60 * 1000) {
     await refreshAccessToken(account)
   }
   ```

### When Reviewing Architecture

- Database schema is in `docs/DATABASE_SCHEMA.md` - this is the source of truth
- All data flows documented in `docs/DATA_FLOWS.md`
- Security requirements in `docs/SECURITY_PRIVACY.md` must be followed
- Platform-specific details in `docs/PLATFORM_*.md` files

### Common Pitfalls to Avoid

1. ❌ Don't bypass RLS unless absolutely necessary (use service role sparingly)
2. ❌ Don't store tokens unencrypted
3. ❌ Don't assume webhooks are reliable (always have polling fallback)
4. ❌ Don't forget to verify webhook signatures
5. ❌ Don't expose user data across tenants
6. ❌ Don't ignore rate limits (implement backoff)
7. ❌ Don't fetch all data at once (use pagination)

## Environment Variables Needed

```bash
# Supabase
SUPABASE_URL=https://{project}.supabase.co
SUPABASE_ANON_KEY=eyJ...  # Public key, safe for client
SUPABASE_SERVICE_KEY=eyJ...  # Secret, server-only!

# Encryption
TOKEN_ENCRYPTION_KEY=...  # 32-byte key for AES-256

# Bluesky
BLUESKY_CLIENT_ID=https://trove.example.com/client-metadata.json
BLUESKY_CLIENT_SECRET=...

# Strava
STRAVA_CLIENT_ID=...
STRAVA_CLIENT_SECRET=...
STRAVA_VERIFY_TOKEN=...  # For webhook verification

# Instagram
INSTAGRAM_APP_ID=...
INSTAGRAM_APP_SECRET=...
```

## Testing Strategy

1. **Unit Tests**: Token encryption, data transformations
2. **Integration Tests**: OAuth flows, API endpoints
3. **RLS Tests**: Verify users can't access other users' data
4. **Sync Tests**: Test with mock platform APIs
5. **End-to-End**: Full flow from OAuth to media download

## Resources & Links

- **Supabase Docs**: https://supabase.com/docs
- **Bluesky Docs**: https://docs.bsky.app/
- **Strava API**: https://developers.strava.com/
- **Instagram API**: https://developers.facebook.com/docs/instagram-api/

## Quick Reference

### Start Working on Trove
1. Read `PLAN.md` for overview
2. Check `docs/DATABASE_SCHEMA.md` for data model
3. Review `docs/SECURITY_PRIVACY.md` for security requirements
4. Check platform-specific docs before integrating

### Need to Understand a Flow?
- OAuth: `docs/DATA_FLOWS.md` → Section 2
- Sync: `docs/DATA_FLOWS.md` → Section 4
- Webhooks: `docs/DATA_FLOWS.md` → Section 3
- Media: `docs/DATA_FLOWS.md` → Section 5

### Adding a New Platform?
1. Research API capabilities (auth, webhooks, rate limits)
2. Create `docs/PLATFORM_{NAME}.md` document
3. Add to `platform_enum` in database
4. Implement OAuth flow
5. Implement sync logic (polling first)
6. Add webhook support if available
7. Test thoroughly

## Notes

- **No frontend yet** - Backend/API only for now
- **Multi-user from day 1** - RLS ensures this
- **Privacy-first** - Only archive public content user already posted
- **Production-ready architecture** - All edge cases considered
- **Documentation-driven** - Implementation follows docs

---

**Last Updated**: 2024-01-24
**Phase**: Planning & Architecture Complete ✅
**Next**: Implementation (Supabase setup)
